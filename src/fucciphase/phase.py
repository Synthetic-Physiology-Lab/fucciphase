from enum import Enum
from typing import List

import numpy as np
import pandas as pd

from .utils import get_norm_channel_name, norm


class NewColumns(str, Enum):
    """Columns generated by the analysis.


    Attributes
    ----------
    CELL_CYCLE_PERC : str
        Unique cell cycle percentage value
    MANUAL_SPOT_COLOR : str
        Color indexing
    PHASE : str
        Phase of the cell cycle
    """

    CELL_CYCLE_PERC = "CELL_CYCLE_PERC"
    MANUAL_SPOT_COLOR = "MANUAL_SPOT_COLOR"
    PHASE = "PHASE"
    DISCRETE_PHASE_MAX = "DISCRETE_PHASE_MAX"
    DISCRETE_PHASE_BG = "DISCRETE_PHASE_BG"
    DISCRETE_PHASE_DIFF = "DISCRETE_PHASE_DIFF"

    @staticmethod
    def cell_cycle() -> str:
        """Return the name of the unique intensity column."""
        return NewColumns.CELL_CYCLE_PERC.value

    @staticmethod
    def phase() -> str:
        """Return the name of the phase column."""
        return NewColumns.PHASE.value

    @staticmethod
    def color() -> str:
        """Return the name of the color column."""
        return NewColumns.MANUAL_SPOT_COLOR.value

    @staticmethod
    def discrete_phase_max() -> str:
        """Return the name of the discrete phase column."""
        return NewColumns.DISCRETE_PHASE_MAX.value

    def discrete_phase_bg() -> str:
        """Return the name of the discrete phase column."""
        return NewColumns.DISCRETE_PHASE_BG.value

    def discrete_phase_diff() -> str:
        """Return the name of the discrete phase column."""
        return NewColumns.DISCRETE_PHASE_DIFF.value

def compute_cell_cycle(
    df: pd.DataFrame, g1_channel: str, s_g2_channel: str
) -> List[str]:
    """Compute a unique cell cycle percentage value using two channels, as well as
    a color indexing. The corresponding columns are added in place in the dataframe.

    The unique intensity is computed as the normalised angle in polar space (g1_channel,
    channel 2). The two channels must have been normalised before using
    fucciphase.utils.normalize_channels().

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe
    g1_channel : str
        First channel
    s_g2_channel : str
        Second channel

    Returns
    -------
    List[str]
        The names of the new columns in the dataframe

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    """
    # sanity check: check that the normalized channels are present
    for channel in [g1_channel, s_g2_channel]:
        if get_norm_channel_name(channel) not in df.columns:
            raise ValueError(
                f"Column {get_norm_channel_name(channel)} not found, call "
                f"normalize_channel({channel}) on the dataframe."
            )

    # get normalized channel names
    g1_channel_norm = get_norm_channel_name(g1_channel)
    s_g2_channel_norm = get_norm_channel_name(s_g2_channel)

    # define cosine and sine
    cos_ch1 = df[g1_channel_norm]
    sin_ch2 = df[s_g2_channel_norm]

    # compute normalised unified intensity
    unified_intensity = norm(np.arctan2(sin_ch2, cos_ch1))

    # compute color (following java plugin) # TODO revisit
    color = np.rint((256**2 + 256 + 1) * 255 * unified_intensity - 256**3)

    # update the dataframe
    df[NewColumns.cell_cycle()] = unified_intensity
    df[NewColumns.color()] = pd.Series(color, dtype=int)  # make sure we add it as int

    return [
        NewColumns.cell_cycle(),
        NewColumns.color(),
    ]


def generate_cycle_phases(
    df: pd.DataFrame, phases: List[str], thresholds: List[float]
) -> None:
    """Add a column in place to the dataframe with the phase of the cell cycle, where
    the phase is determined using a threshold on the cell cycle percentage.

    The dataframe must have been previously processed using the compute_cell_cycle()
    function.

    The thresholds must be between 0 and 1, 1 excluded, and must be unique. Each
    threshold is the upper bound for the corresponding phase, the last phase being the
    one attributed to values larger than all thresholds.

    Example:
        phases = ["EG1", "G1", "T", "G2M"]
        threshold = [0.04, 0.4, 0.56]

    TODO: indications on how to determine the thresholds experimentally.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe with a CELL_CYCLE_PERC column
    phases : List[str]
        List of phases corresponding to the thresholds
    thresholds : List[float]
        List of cell cycle percentage thresholds, must be between 0 and 1.

    Raises
    ------
    ValueError
        If the CELL_CYCLE_PERC column is missing
    ValueError
        If the number of phases and thresholds do not match (one more phase expected)
    ValueError
        If the thresholds are not unique
    ValueError
        If the phases are not unique
    ValueError
        If the thresholds are not between 0 and 1, one excluded
    """
    # check that the cell cycle column is present
    if NewColumns.cell_cycle() not in df.columns:
        raise ValueError(
            f"Column {NewColumns.cell_cycle()} not found, call "
            f"compute_cell_cycle() on the dataframe."
        )

    # check that the number of phases and thresholds match
    if len(phases) != len(thresholds) + 1:
        raise ValueError(
            f"There must be one more phase than thresholds (got {len(phases)} for "
            f"{len(thresholds)} thresholds)."
        )

    # check that all thresholds are unique
    if len(thresholds) != len(set(thresholds)):
        raise ValueError("Thresholds must be unique.")

    # check that all phases are unique
    if len(phases) != len(set(phases)):
        raise ValueError("Phases must be unique.")

    # check that the thresholds are between 0 and 1
    if not all(0 < t < 1 for t in thresholds):
        raise ValueError("Thresholds must be between 0 and 1.")

    # sort the thresholds and phases by increasing threshold
    # in case they are given in the wrong order
    # sort according to the thresholds:
    sorted_phases = [x for _, x in sorted(zip(thresholds, phases[:-1]))]
    sorted_phases.append(phases[-1])  # add the last element back

    sorted_thresholds = sorted(thresholds)

    # add 1 since the thresholds will be used as bin edges
    sorted_thresholds = [0, *list(sorted_thresholds), 1.1]

    # get the cell cycle column
    cell_cycle = df[NewColumns.cell_cycle()]

    # compute a new column with the phases, each phase attributed using the
    # thresholds on the cell cycle value
    df[NewColumns.phase()] = pd.cut(
        cell_cycle, bins=sorted_thresholds, labels=sorted_phases, right=False
    )


def estimate_cell_phase_from_max_intensity(
    df: pd.DataFrame,
    g1_channel: str,
    s_g2_channel: str,
    g1_background: float,
    s_g2_background: float,
    g1_threshold: float,
    s_g2_threshold: float,
) -> None:
    """Add a column in place to the dataframe with the estimated phase of the cell
    cycle, where the phase is determined by thresholding the channel intensities.

    The provided thresholds are used to decide if a channel is switched on (ON).
    For that, the background is subtracted from the mean intensity.
    The obtained values are normalized w.r.t. the maximum mean intensity in the
    respective channel available in the DataFrame.
    Hence, the threshold values should be between 0 and 1.
    This method will not work reliably if not enough cells from different phases
    are contained in the DataFrame.


    Parameters
    ----------
    df: pd.DataFrame
        Dataframe with a CELL_CYCLE_PERC column
    g1_channel : str
        First channel indicating G1
    s_g2_channel : str
        Second channel indicating S/G2
    g1_background: float
        Single value representing background of channel
    s_g2_background: float
        Single value representing background of channel
    g1_threshold:
        Threshold to consider G1 channel ON
    s_g2_threshold: float
        Threshold to consider S/G2 channel ON

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    ValueError
        If the thresholds are not between 0 and 1.
    """
    # sanity check: check that channels are present
    for channel in [g1_channel, s_g2_channel]:
        if channel not in df.columns:
            raise ValueError(
                f"Column {channel} not found, provide correct input parameters."
            )
    # check thresholds
    if not 0 < g1_threshold < 1 and not 0 < s_g2_threshold < 1:
        raise ValueError("Provide threshold values between 0 and 1.")

    # get intensities and subtract background
    g1_channel_intensity = df[g1_channel] - g1_background
    s_g2_channel_intensity = df[s_g2_channel] - s_g2_background

    # threshold channels to decide if ON / OFF (data is in list per spot)
    g1_on_channel = g1_channel_intensity > g1_threshold * g1_channel_intensity.max()
    s_g2_on_channel = (
        s_g2_channel_intensity > s_g2_threshold * s_g2_channel_intensity.max()
    )

    # store phases
    phase_names = []
    for g1_on, s_g2_on in zip(g1_on_channel, s_g2_on_channel):
        phase_names.append(discrete_phase_logic(g1_on, s_g2_on))
    df[NewColumns.discrete_phase_max()] = pd.Series(phase_names, dtype=str)  # add as str


def estimate_cell_phase_from_background(
    df: pd.DataFrame,
    g1_channel: str,
    s_g2_channel: str,
    g1_background: float,
    s_g2_background: float,
    g1_factor: float,
    s_g2_factor: float,
) -> None:
    """Add a column in place to the dataframe with the estimated phase of the cell
    cycle, where the phase is determined by comparing the channel intensities to
    the respective background intensities.

    The provided factors are used to decide if a channel is switched on (ON).
    If the intensity exceeds the background level times the factor, the channel
    is ON. Hence, the factors should be greater than 0.


    Parameters
    ----------
    df: pd.DataFrame
        Dataframe with a CELL_CYCLE_PERC column
    g1_channel : str
        First channel indicating G1
    s_g2_channel : str
        Second channel indicating S/G2
    g1_background: float
        Single value representing background of channel
    s_g2_background: float
        Single value representing background of channel
    g1_factor: float
        Factor to consider G1 channel ON
    s_g2_factor: float
        Factor to consider S/G2 channel ON

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    ValueError
        If the factors are not greater than 0.
    """
    # sanity check: check that channels are present
    for channel in [g1_channel, s_g2_channel]:
        if channel not in df.columns:
            raise ValueError(
                f"Column {channel} not found, provide correct input parameters."
            )
    # check thresholds
    if not g1_factor > 0 and not s_g2_factor > 0:
        raise ValueError("Provide factors greater than 0.")

    # get intensities and subtract background
    g1_channel_intensity = df[g1_channel]
    s_g2_channel_intensity = df[s_g2_channel]

    # threshold channels to decide if ON / OFF (data is in list per spot)
    g1_on_channel = g1_channel_intensity > g1_factor * g1_background
    s_g2_on_channel = s_g2_channel_intensity > s_g2_factor * s_g2_background

    # store phases
    phase_names = []
    for g1_on, s_g2_on in zip(g1_on_channel, s_g2_on_channel):
        phase_names.append(discrete_phase_logic(g1_on, s_g2_on))
    df[NewColumns.discrete_phase_bg()] = pd.Series(phase_names, dtype=str)  # add as str

def discrete_phase_logic(g1_on: bool, s_g2_on: bool) -> str:
    """Return the discrete phase based channel ON / OFF data."""
    if not g1_on and not s_g2_on:
        return "EG1"
    elif g1_on and not s_g2_on:
        return "G1"
    elif not g1_on and s_g2_on:
        return "S/G2/M"
    else:
        return "T"
