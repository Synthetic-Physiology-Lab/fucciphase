from enum import Enum
from typing import List, Tuple

import numpy as np
import pandas as pd

from .utils import get_norm_channel_name, norm


class NewColumns(str, Enum):
    """Columns generated by the analysis."""

    MEAN_INTENSITY_UNIQUE_VALUE = "MEAN_INTENSITY_UNIQUE_VALUE"
    PHASE = "PHASE"
    MANUAL_SPOT_COLOR = "MANUAL_SPOT_COLOR"

    @staticmethod
    def unique_intensity() -> str:
        """Return the name of the unique intensity column."""
        return NewColumns.MEAN_INTENSITY_UNIQUE_VALUE.value

    @staticmethod
    def phase() -> str:
        """Return the name of the phase column."""
        return NewColumns.PHASE.value

    @staticmethod
    def color() -> str:
        """Return the name of the color column."""
        return NewColumns.MANUAL_SPOT_COLOR.value


class PhasesName(str, Enum):
    """Phases of the cell cycle."""

    EARLY_G1 = "EG1"
    G1 = "G1"
    S = "T"  # TODO: why not S?
    G2_M = "G2/M"


class FucciPhase:
    """FUCCI phases normalized intensity.

    TODO: add explanations.

    Time spent in each phase:
        (python)
        - EG1 4%
        - G1 36%
        - S 5%
        - G2M 55%

        (java)
        double maxEG1 = 0.04; -> 4%
        double maxG1 = 0.4; -> 36%
        double maxT = 0.46; -> 6%
        double maxG2_M = 1; -> 54%

    In order to order a color code across phases, we create a 255-range
    with each phase start and end adjusted:
        - EG1 from 0 to 3
        - G1 from 4 to 40
        - S from 41 to 46
        - G2M from 47 to 100

    # TODO currently wrong (percentage vs 255 scale)

    """

    start_early_G1 = 0
    end_early_G1 = 4
    start_G1 = 5
    end_G1 = 95
    start_S = 96
    end_S = 113
    start_G2_M = 114
    end_G2_M = 255

    # TODO unify both
    perc_end_EG1 = 0.04
    perc_end_G1 = 0.4
    perc_end_S = 0.46
    perc_end_G2_M = 1


def _get_phase_bichannel(intensity1: float, intensity2: float) -> Tuple[str, int, int]:
    """Return the phase of the cell cycle, and its intensity range based on
    the values of two channels intensity.

    TODO: description of the two channels

    Parameters
    ----------
    intensity1 : float
        Normalized intensity of channel 1.
    intensity2 : float
        Normalized intensity of channel 2.

    Returns
    -------
    Tuple[Phase, int, int]
        The phase of the cell cycle, and its intensity range (start and end).
    """
    if intensity1 <= 0.1 and intensity2 <= 0.1:
        return (
            PhasesName.EARLY_G1.value,
            FucciPhase.start_early_G1,
            FucciPhase.end_early_G1,
        )
    elif intensity1 <= 0.1 and intensity2 > 0.1:
        return PhasesName.G1.value, FucciPhase.start_G1, FucciPhase.end_G1
    elif intensity1 > 0.1 and intensity2 > 0.1:
        return PhasesName.S.value, FucciPhase.start_S, FucciPhase.end_S
    else:
        return PhasesName.G2_M.value, FucciPhase.start_G2_M, FucciPhase.end_G2_M


def compute_phase_bichannel(
    df: pd.DataFrame, channel1: str, channel2: str
) -> List[str]:
    """Compute the cell cycle percentage, the phase and a color for each spot, and add
    in place the data as new columns.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe
    channel1 : str
        First channel
    channel2 : str
        Second channel

    Returns
    -------
    List[str]
        The names of the new columns in the dataframe

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    """
    # sanity check: check that the normalized channels are present
    for channel in [channel1, channel2]:
        if get_norm_channel_name(channel) not in df.columns:
            raise ValueError(
                f"Column {get_norm_channel_name(channel)} not found, call "
                f"normalize_channel({channel}) on the dataframe."
            )

    # get normalized channel names
    channel1_norm = get_norm_channel_name(channel1)
    channel2_norm = get_norm_channel_name(channel2)

    # initialize the lists
    n_rows = len(df)
    mean_intensity_unique = np.zeros(n_rows)
    color_factor = np.zeros(n_rows)
    color_offset = np.zeros(n_rows)
    phase_label = []

    # loop over the rows of the dataframe
    for index, row in df.iterrows():
        ch1_norm = row[channel1_norm]
        ch2_norm = row[channel2_norm]

        # get fucci phase, and its start and end
        phase, start, end = _get_phase_bichannel(ch1_norm, ch2_norm)
        phase_label.append(phase)

        # record factor and offset
        color_factor[index] = end - start
        color_offset[index] = start

        # record unique mean
        if phase == PhasesName.G1:  # TODO this was strange in the python code
            mean_intensity_unique[index] = ch1_norm
        else:
            mean_intensity_unique[index] = ch2_norm

    # compute color intensity, rounded as an int vector
    color_intensity = np.rint(
        mean_intensity_unique * color_factor + color_offset,
    )
    color_str = [f"r={val};g={val};b={val};" for val in color_intensity]

    # update the dataframe
    df[NewColumns.unique_intensity()] = mean_intensity_unique
    df[NewColumns.phase()] = phase
    df[NewColumns.color()] = color_str

    return [
        NewColumns.unique_intensity(),
        NewColumns.phase(),
        NewColumns.color(),
    ]


def _get_phase_trigo(normalised_intensity: np.ndarray) -> List[str]:
    """Return a vector of the phase corresponding to the normalised intensity.

    Parameters
    ----------
    normalised_intensity : np.ndarray
        Normalised intensity

    Returns
    -------
    np.ndarray
        Phases vector
    """
    phase = []

    for _, val in enumerate(normalised_intensity):
        if val <= FucciPhase.perc_end_EG1:
            phase.append(PhasesName.EARLY_G1.value)
        elif val <= FucciPhase.perc_end_G1:
            phase.append(PhasesName.G1.value)
        elif val <= FucciPhase.perc_end_S:
            phase.append(PhasesName.S.value)
        else:
            phase.append(PhasesName.G2_M.value)

    return phase


def compute_phase_trigo(df: pd.DataFrame, channel1: str, channel2: str) -> List[str]:
    """Compute a unique intensity, phase and color using the two channels and
    add the corresponding columns in place in the dataframe.

    The unique intensity is computed as the normalised angle between the normalised
    intensity on a circle.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe
    channel1 : str
        First channel
    channel2 : str
        Second channel

    Returns
    -------
    List[str]
        The names of the new columns in the dataframe

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    """
    # sanity check: check that the normalized channels are present
    for channel in [channel1, channel2]:
        if get_norm_channel_name(channel) not in df.columns:
            raise ValueError(
                f"Column {get_norm_channel_name(channel)} not found, call "
                f"normalize_channel({channel}) on the dataframe."
            )

    # get normalized channel names
    channel1_norm = get_norm_channel_name(channel1)
    channel2_norm = get_norm_channel_name(channel2)

    # compute cosine and sine
    cos_ch1 = np.cos(df[channel1_norm])
    sin_ch2 = np.sin(df[channel2_norm])

    # compute normalised angle
    angle = norm(np.arctan2(sin_ch2, cos_ch1))

    # compute gray value
    gray_value = [f"r{val};g{val};b{val};" for val in angle * 255]

    # compute phases
    phase = _get_phase_trigo(angle)

    # update the dataframe
    df[NewColumns.unique_intensity()] = angle
    df[NewColumns.phase()] = phase
    df[NewColumns.color()] = gray_value

    return [
        NewColumns.unique_intensity(),
        NewColumns.phase(),
        NewColumns.color(),
    ]
