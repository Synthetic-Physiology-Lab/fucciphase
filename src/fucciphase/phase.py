from enum import Enum
from typing import List, Tuple

import numpy as np
import pandas as pd

from .utils import get_norm_channel_name


class NewColumns(str, Enum):
    """Columns generated by the analysis."""

    MEAN_INTENSITY_UNIQUE_VALUE = "MEAN_INTENSITY_UNIQUE_VALUE"
    PHASE = "PHASE"
    MANUAL_SPOT_COLOR = "MANUAL_SPOT_COLOR"

    @staticmethod
    def unique_intensity() -> str:
        """Return the name of the unique intensity column."""
        return NewColumns.MEAN_INTENSITY_UNIQUE_VALUE.value

    @staticmethod
    def phase() -> str:
        """Return the name of the phase column."""
        return NewColumns.PHASE.value

    @staticmethod
    def color() -> str:
        """Return the name of the color column."""
        return NewColumns.MANUAL_SPOT_COLOR.value


class Phase(str, Enum):
    """Phase of the cell cycle."""

    EARLY_G1 = "EG1"
    G1 = "G1"
    S = "T"  # TODO: why not S?
    G2_M = "G2/M"


class FucciColorIndex:
    """FUCCI phases normalized intensity.

    TODO: add explanations.

    Time spent in each phase:
        - EG1 4%
        - G1 36%
        - S 5%
        - G2M 55%

    In order to order a color code across phases, we create a 255-range
    with each phase start and end adjusted:
            - EG1 from 0 to 3
        - G1 from 4 to 40
        - S from 41 to 46
        - G2M from 47 to 100

    # TODO currently wrong

    """

    start_early_G1 = 0
    end_early_G1 = 4
    start_G1 = 5
    end_G1 = 95
    start_S = 96
    end_S = 113
    start_G2_M = 114
    end_G2_M = 255


def _get_phase_bichannel(
    intensity1: float, intensity2: float
) -> Tuple[Phase, int, int]:
    """Return the phase of the cell cycle, and its intensity range based on
    the values of two channels intensity.

    TODO: description of the two channels

    Parameters
    ----------
    intensity1 : float
        Normalized intensity of channel 1.
    intensity2 : float
        Normalized intensity of channel 2.

    Returns
    -------
    Tuple[Phase, int, int]
        The phase of the cell cycle, and its intensity range (start and end).
    """
    if intensity1 <= 0.1 and intensity2 <= 0.1:
        return (
            Phase.EARLY_G1,
            FucciColorIndex.start_early_G1,
            FucciColorIndex.end_early_G1,
        )
    elif intensity1 <= 0.1 and intensity2 > 0.1:
        return Phase.G1, FucciColorIndex.start_G1, FucciColorIndex.end_G1
    elif intensity1 > 0.1 and intensity2 > 0.1:
        return Phase.S, FucciColorIndex.start_S, FucciColorIndex.end_S
    else:
        return Phase.G2_M, FucciColorIndex.start_G2_M, FucciColorIndex.end_G2_M


def compute_phase_bichannel(
    df: pd.DataFrame, channel1: str, channel2: str
) -> List[str]:
    """Compute the cell cycle percentage, the phase and a color for each spot, and add
    in place the data as new columns.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe
    channel1 : str
        First channel
    channel2 : str
        Second channel

    Returns
    -------
    List[str]
        The names of the new columns in the dataframe

    Raises
    ------
    ValueError
        If the dataframe does not contain the normalized channels.
    """
    # sanity check: check that the normalized channels are present
    for channel in [channel1, channel2]:
        if get_norm_channel_name(channel) not in df.columns:
            raise ValueError(
                f"Column {get_norm_channel_name(channel)} not found, call "
                f"normalize_channel({channel}) on the dataframe."
            )

    # get normalized channel names
    channel1_norm = get_norm_channel_name(channel1)
    channel2_norm = get_norm_channel_name(channel2)

    # initialize the lists
    n_rows = len(df)
    mean_intensity_unique = np.zeros(n_rows)
    color_factor = np.zeros(n_rows)
    color_offset = np.zeros(n_rows)
    phase_label = []

    # loop over the rows of the dataframe
    for index, row in df.iterrows():
        ch1_norm = row[channel1_norm]
        ch2_norm = row[channel2_norm]

        # get fucci phase, and its start and end
        phase, start, end = _get_phase_bichannel(ch1_norm, ch2_norm)
        phase_label.append(phase.value)

        # record factor and offset
        color_factor[index] = end - start
        color_offset[index] = start

        # record unique mean
        if phase == Phase.G1:  # TODO this was strange in the python code
            mean_intensity_unique[index] = ch1_norm
        else:
            mean_intensity_unique[index] = ch2_norm

    # compute color intensity, rounded as an int vector
    color_intensity = np.rint(
        mean_intensity_unique * color_factor + color_offset,
    )
    color_str = [f"r={val};g={val};b={val};" for val in color_intensity]

    # update the dataframe
    df[NewColumns.unique_intensity()] = mean_intensity_unique
    df[NewColumns.phase()] = phase
    df[NewColumns.color()] = color_str

    return [
        NewColumns.unique_intensity(),
        NewColumns.phase(),
        NewColumns.color(),
    ]


def compute_phase_trigo(df: pd.DataFrame, channel1: str, channel2: str) -> List[str]:
    """_summary_.

    Parameters
    ----------
    df : pd.DataFrame
        _description_
    channel1 : str
        _description_
    channel2 : str
        _description_

    Returns
    -------
    List[str]
        _description_

    Raises
    ------
    ValueError
        _description_
    """
    # sanity check: check that the normalized channels are present
    for channel in [channel1, channel2]:
        if get_norm_channel_name(channel) not in df.columns:
            raise ValueError(
                f"Column {get_norm_channel_name(channel)} not found, call "
                f"normalize_channel({channel}) on the dataframe."
            )

    # get normalized channel names
    channel1_norm = get_norm_channel_name(channel1)
    channel2_norm = get_norm_channel_name(channel2)

    # compute cosine and sine
    cos_ch1 = np.cos(df[channel1_norm])
    sin_ch2 = np.sin(df[channel2_norm])

    # compute angle
    np.arctan2(sin_ch2, cos_ch1)

    return []
